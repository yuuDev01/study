# **📁 정렬 알고리즘 (Sorting Algorithm)**

정렬되지 않은 데이터를 순서대로 배치하는 알고리즘.

효율적인 정렬은 탐색, 병합 알고리즘 등 정렬된 데이터를 필요로하는 알고리즘의 효율성의 최적화하는 데 중요하다.

### **📑정렬 알고리즘 종류**

\- 삽입 정렬 (Insertion Sort)

\- 선택 정렬 (selection Sort) 

\- 버블 정렬(Bubble Sort)

\- 퀵 정렬(Quick Sort)

\- 히프 정렬(Heap sort)

\- 합병 정렬(Merge sort)

### **📝삽입 정렬(Insertion Sort)**

배열의 선택한 요소를 그 앞에 이미 정렬된 배열 부분과 비교하여, 올바른 위치를 찾아 삽입하여 정렬하는 알고리즘.

[##_Image|kage@YU9LJ/btshVBIxKWs/gK3tgIDj1MKPnmTolufl2k/img.png|CDM|1.3|{"originWidth":524,"originHeight":410,"style":"floatLeft","width":314,"filename":"blob"}_##]

두 번째 원소를 key 값으로 하여 그 앞의 원소와 비교

5 > key : key값이 더 작으므로 앞의 원소를 뒤로 옮긴다.

더 이상 비교할 원소가 없기 때문에 1회전 종료

[##_Image|kage@k9ePj/btshA4svR3x/OeE8bqsS853dk2rbKJsamk/img.png|CDM|1.3|{"originWidth":524,"originHeight":275,"style":"floatLeft","width":314,"filename":"blob"}_##][##_Image|kage@bzjxOB/btshWtQ98md/GwEjCaixjSmIKYD0jKJMEk/img.png|CDM|1.3|{"originWidth":520,"originHeight":444,"style":"floatLeft","width":312,"filename":"blob"}_##]

 세 번째를 key값으로 하여 그 앞의 원소들과 비교

 5 > key :  key값이 더 작으므로 앞의 원소를 뒤로 옮긴다.

 2 < key : key값이 더 크므로 자리를 바꾸지 않는다.

더 이상 비교할 원소가 없기 때문에 2회전 종료

네 번째를 key값으로 하여 그 앞의 원소들과 비교

 5 > key :  key값이 더 작으므로 앞의 원소를 뒤로 옮긴다.

 3 < key : key값이 더 작으므로 앞의 원소를 뒤로 옮긴다.

 2 < key : key값이 더 작으므로 앞의 원소를 뒤로 옮긴다.

더 이상 비교할 원소가 없기 때문에 2회전 종료

[##_Image|kage@cdEdhu/btshZu3kRFO/NtDlulFc2bMMX7UvUeNV1k/img.png|CDM|1.3|{"originWidth":515,"originHeight":278,"style":"floatLeft","width":311,"height":168}_##]

마지막 원소를 key값으로 하여 그 앞의 원소들과 비교

 5 > key :  key값이 더 작으므로 앞의 원소를 뒤로 옮긴다.

 3 > key : key값이 더 크므로 자리를 바꾸지 않는다.

그 앞의 원소들도 key값보다 작기 때문에  4회전 종료

```
def insertion_sort(arr):
	for i in range(1, len(arr)): # 두 번째 원소부터 마지막까지 
		j = i - 1   # 비교할 원소
		key = arr[i] # 정렬할 원소
		while arr[j] > key and j >= 0:  # 배열 내에서 key가 비교할 원소보다 작을 때 까지 반복
			arr[j+1] = arr[j] # 비교한 원소를 뒤로 옮기기
			j = j - 1 # 그 앞의 원소자리로 이동
		arr[j+1] = key # 찾은 자리에 key값 넣기
	return arr
```

```
def insertion_sort(arr):
    for i in range(1, len(arr)):
        # i부터 맨 앞까지 한 칸씩 이동하며 비교
        for j in range(i, 0, -1):
            만약 앞의 원소가 더 클 경우 자리 바꾸기
            if arr[j] < arr[j - 1]:
                arr[j], arr[j - 1] = arr[j - 1], arr[j]
            # 앞의 원소가 작을 경우 break문으로 for문 빠져나옴
            else:
                break
    return arr
```

#### **👉 시간복잡도**

n개의 데이터가 있을 때, 이미 정렬되어 있는 최선의 경우 O(N) / 최악의 경우 O(n²) / 평균 O(n²) 의 시간 복잡도를 가진다.